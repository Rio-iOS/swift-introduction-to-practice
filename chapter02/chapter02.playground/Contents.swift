import Foundation

/*
 変数と定数：プログラムに登場する値を追記する入れ物
 - 変数と定数は一定の範囲内のプログラムから参照可能
 - 必要に応じて値を再利用できる
 - 変数や定数への値の保存や、変数や定数からの値の取り出しは、式を通じて行う
 
 Swift：変数と定数による値の管理
 - 変数と定数は、値の一時的な保存に使う
 - ある処理の結果を変数や定数に保存すると、後続の処理でその結果を再利用できる
 - 代入：変数や定数に値を入れること
 - 変数には何度でも値を代入できる
 - 定数には一度だけ値を代入できない
 - 変数と定数を適切に使い分けることで、値が変化する可能性を明示する
 - 全ての変数と定数は、それぞれの型を持つ
 */

// 宣言方法
// 型アノテーション（type annotation）：型名を表す部分
// 式（expression）：変数や定数、演算子などを組み合わせたもの
// 初期化：変数や定数への最初の代入
// var 変数名: 型名
var a: Int

// let 定数名: 型名
let b: Int

// 値の代入方法
// 変数名 or 定数名 = 代入する値
a = 1
b = 1
print(a)
print(b)

// 宣言と代入を一括で行う
let constantA: Int = 123
print(constantA)

// 型アノテーションで指定した値と代入する値が一致しない場合は、コンパイルエラー
// bad：let b: Int = "abc"

// 式が返す値の型や定数の型と一致する場合、変数や定数に代入できる
let constantA2 = 1 + 2
print(constantA2)

// 代入による型推論
let constantA3 = 123 // Int型の定数
let constantB = "abc" // String型の定数

// 定数への再代入はコンパイルエラー
// let a = 123
// bad：a = 2

// 値の利用方法
let constantA4 = b

// 初期化されていない変数や定数は値を持っていないため、変数や定数の値を参照する式では値を取り出すことができない

// 型の確認方法：type(of: 式)
print(type(of: a))

/*
 - スコープ：名前の有効範囲
 - スコープ：変数、定数、関数、型の名前の有効範囲を表すもの
 - 同じスコープ内には同じ名前を複数存在させることはできない
    - 変数、定数、関数、型の種類が異なっていても名前は一意である必要がある
 - グルーバルスコープ：プログラム全体から参照できるスコープ
    - グローバルスコープで宣言された変数や定数はどこからでも同じ名前で参照でき、意図しない変更を招きやすいため、ローカルスコープで宣言された変数や定数よりも説明的な命名が必要
 - ローカルスコープ：局所的に定義されるスコープ
    - ローカルスコープで宣言された変数や定数は、関数や制御構文が持つ実行文の内部のみで有効、スコープ外部からは参照できない
 
 - 同じスコープ内に同じ名前を複数存在させることはできないが、異なるスコープには同じ名前を存在させることができる
 - 異なるスコープに同一の名前が存在する場合、名前を参照するスコープから最も近い祖先のスコープにあるものが優先される
 
*/

func someFunction() {
    let a = "a"
    print(a)
}
// bad：print(a)
someFunction()

let globalA = "a"
func someFunction2() {
    print(globalA)
}
someFunction2()

let a2 = 1
func someFunction3() {
    let a2 = 2
    print("local a:", a2)
}
someFunction3()
print("global a:", a2)

/*
 Swift：式の組み立て
 - 式：値の変更、値の返却、もしくはその両方を行う
 - 値の返却のみを行う式
 - 演算を行う式
 - 処理を呼び出す式
 */

// 値の返却のみを行う式
// 変数や定数の値を返却する式
let a3 = 1
let b2 = a3 + 1

// リテラル式：値をプログラムに直接表する式
// リテラルとは、1や"abc"などの値をプログラムに直接表記する書式
// 整数リテラルや文字列リテラル
// 配列リテラル、辞書リテラル、nilリテラルのように、デフォルトの型を持たないリテラルもある
let a4 = 123
print(type(of: a4))
let b3 = "abc"
print(type(of: b3))

// 型アノテーションが存在する場合、代入するリテラルの型が違うとコンパイルエラー
// bad： let a: String = 1


// メンバー式：型のメンバーにアクセスする式
// 型のメンバー：型の値や型自身に紐付く変数、定数、関数、型などのこと
// プロパティ：値に紐付く変数や定数のこと
// メソッド：型に紐付く関数のこと
// 式.メンバー名
let a5 = "Hello World"
print(a5.count)
print(a5.starts(with: "Hello"))


// クロージャー式：呼び出し可能な処理を定義する式
// クロージャー：処理をまとめて呼び出し可能にしたもの
// 引数：クロージャーの入力値
// 戻り値：出力値
// クロージャー式は、クロージャーを定義する式で、主に処理を定義して他の処理に渡す際に使う
// {引数 in 戻り値を返す式}

let original = [1, 2, 3]
let doubled = original.map({ value in value * 2})
print(doubled)


// 演算を行う式：演算子の種類に応じて演算を行い、演算の結果の値を返す式である
// 前置演算子、中置演算子、後置演算子の3つに分かれる
// (ex) -a, a+b, a!
// 算術演算子（+, -, *, /, %）
print(27 * 13)
print(4.5 * 8.1)

let int = 27
let double = 0.3
// bad: print(int * double)
// 暗黙的な型変換による想定外の桁の損失を防ぐというメリットがある
// 型の安全性を重視した、Swiftらしい仕様
print(Double(int) * double)

// 符号演算子（数値の符号を指定する演算子）
let a6 = 7
// 符号演算子「-」は、数値のプラスとマイナスの符号を反転する前置演算子
print(-a6)

// 否定演算子（論理値の反転を行う演算子）
// 否定演算子「!」は、真理値を反転する前置演算子
// 真理値：命題が真であるか偽であるかを表す値であり、Bool型で表現される
// 真理値リテラル：true or false
let a7 = false
print(!a7)

// 処理を呼び出す式
// 関数を呼び出す式
// 関数：処理をまとめて呼び出し可能にしたもの
// 引数：関数の入力値
// 戻り値：出力値
// 関数の呼び出し方法：関数名(引数名1: 引数1, 引数名2: 引数2...)
print(max(2, 7))


// イニシャライザを呼び出す式
// イニシャライザ：型のインスタンスを生成するための処理をまとめたもの
// 型のインスタンス：型の実態
// 型：値の種類
// イニシャライザを呼び出す式：型名(引数名1: 引数1, 引数名2: 引数2...)
print(type(of: String(4)))
