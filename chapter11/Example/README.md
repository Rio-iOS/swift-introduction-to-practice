# 第11章 モジュール

## モジュールとは？
モジュール：複数のソースコードを含む配布可能なプログラムの単位
    - 他のプログラムへのインポートが可能
    - プログラムの名前空間を区切る単位


## 11.1 再利用可能かつ配布可能なプログラム
特定のプロジェクトからの独立性が高いプログラムは、他のプロジェクトでも再利用できる可能性がある。
モジュールには、そのような汎用的なプログラムをうまく再利用するためのしくみが備わっています。
- (ex)
- 名前空間を定義することでモジュール間の名前の衝突を解消する
- 公開するインタフェースを絞ることでモジュール外からの想定外の利用を防ぐ


## 11.2 モジュールの作成と利用
モジュールを作成するには、「**Swift Package Manager**」で「**ビルドターゲット**」を定義する。

```
...$ mkdir Example

...$ cd Example

...$ touch Package.swift
```

```
# swift-tools-versionのバージョン確認
...$ swift -version
```
// Package.swift
- パッケージやビルドターゲットには、「**大文字始まりの名前をつける**」のが一般的である。
- ビルドターゲットがエントリポイントのmain.swiftを含む場合は、ビルドターゲットの名前が実行ファイルの名前となるため、小文字始まりの名前を付けることもある
```

// swift-tools-version:5.5.2

import PackageDescription

let package = Package(
    name: "Example",
    targets: [
        .target(name: "Library")
    ]
)
```

// 定義したターゲット名と同名のディレクトリをSources以下に作成
- ビルドターゲットに含めるソースコードは、Sourcesディレクトリ以下に配置する
- 配置されたソースコードはビルだターゲットに含まれ、モジュールとして外部のプログラムから再利用可能となる
- エントリポイントのmain.swiftが含まれる場合は、外部のプログラムから利用できなくなる
```
...$ mkdir -p Sources/Library
```

// ビルドターゲットの依存関係の定義
- あるモジュールから他のモジュールを利用可能にするには、マニフェストファイルPackage.swiftに依存関係を記述する   - ビルドターゲットの定義の引数dependenciesに、[String]型でターゲット名を["ターゲット名"]のように記述する
        - パッケージ内にLibraryとAnotherLibraryというビルドターゲットがあったとして、AnotherLibraryからLibraryを利用する場合、依存関係を以下のように定義

```
// swift-tools-version:5.5.2

import PackageDescription

let package = Package(
    name: "Example",
    targets: [
        .target(name: "Library"),
        .target(name: "AnotherLibrary", dependencies: ["Library"]),
    ]
)
```

// 外部パッケージの利用
Swift Package Managerは、パッケージ内のモジュールだけでなく、「外部パッケージのモジュール」も利用できる。
外部パッケージの利用の設定は、マニフェストファイルPackage.swiftで行う。
Package型のイニシャライザの引数dependenciesに、利用するパッケージの「URL」と「バージョン」のセット列挙する。

```
// swift-tools-version:5.5.2

import PackageDescription

let package = Package(
    name: "Example",
    dependencies: [
        .package(url: "https://github.com/ReactiveX/RxSwift.git", .upToNextMajor(from: "6.0.0")),
    ],
    targets: [
        .target(name: "Library", dependencies: ["RxSwift"]),
    ]
)
```

## 11.3 名前空間：名前が一意となる範囲
- 名前空間：型名や変数名や定数名や関数名などの名前が一意となる範囲
    - モジュールは名前空間を区切る単位となっており、1つのモジュールを定義すると1つの名前空間が定義される
    - 同じモジュール内のグローバルスコープでは、同一の名前を持つ型、変数、定数、関数を複数させることはできないが、別のモジュールであれば可能である。


// import文：モジュールのインポートを行う文
- 同一モジュール内であれば、そのアクセスレベルがprivateやfileprivateでない限り、別のファイルの要素であっても自由にアクセスできる。
-別のモジュールにある要素にアクセスするには、import文を使用して事前にそのモジュールをインポートする必要がある- インポートを行うと、インポートしたファイル内では、インポートされたモジュールが公開している型や変数、定数を、モジュール内の型や変数、定数として同時に扱える
- import文によるインポートの有効範囲は、ファイル単位である。

```
import モジュール名

// ここではモジュールで公開されている要素に何も指定することなくアクセス可能
```

// 名前の衝突の回避
- モジュールは名前空間の単位でもあるため、モジュール間で使用する名前が重複しても問題ない
- インポートした複数のモジュール間で重複した名前を使用するときは、あいまいさを回避するためになめの先頭にモジュール名を加えて明示する必要がある
- どのモジュールを指しているのかあいまいなものは、コンパイルエラーとして指摘される

```
モジュール名.定数名
```

```
// 例
import FrameworkA
import FrameworkB

// FrameworkAで定義されたglobalIntConstantが代入される
let a = FrameworkA.globalIntConstant

// FrameworkBで定義されたglobalIntConstantが代入される
let b = FrameworkB.globalIntConstant

// globalIntConstantが指すのもあいまいなのでコンパイルエラー
let c = globalIntConstant
```

## 11.4 アクセスコントロール：外部からの使用の制限
- アクセスコントロール：モジュール内の型や型の要素に対する外部からのアクセスを制御するしくみ
- アクセスコントロールを行うには、「アクセスレベル」を指定する
- 適切なアクセスレベルを指定することで、内部的な処理に外部からアクセスできないようにしつつ、モジュール外からの利用を想定したもののみを外部に公開できる
- モジュール外に公開されたインタフェースは、モジュールヘッダを通じて確認できる。
- 適切なアクセスレベルを指定することは、モジュールが想定していない方法で利用されることを防ぐだけではなく、利用者から見て、余計な情報のない理解しやすいインタフェースを提供することにも繋がる


// アクセスレベル：公開範囲の分類
- アクセスレベルを指定することで、外部からの個々の要素へのアクセス可能な範囲を指定できる。
アクセスレベルには、公開範囲が広い順序に以下の5つがある
    - open：モジュール内外のすべてのアクセスを許可する
    - public：モジュール内外のすべてのアクセスを許可するが、モジュール外ではクラスを継承したりオーバーライドしたりすることはできない
    - internal：同一モジュール内のアクセスのみを許可する
    - fileprivate：同一ソースファイル内のアクセスのみを許可する
    - private：対象の要素が属しているスコープ内のアクセスのみを許可する

- モジュール外に利用されるAPIは、アクセスレベルがopenとpublicのものだけ


// デフォルトのアクセスレベル
- 型全体のアクセスレベルと、プロパティやメソッドなどの型を構成する要素のアクセスレベルは独立している。
- 何も指定しない場合は、「デフォルトのアクセスレベル」となる
- 型全体のデフォルトのアクセスレベルは、「internal」である
- 型を構成するデフォルトのアクセスレベルは、型全体のアクセスレベルによって異なる。
    - 型全体のアクセスレベルが、private、fileprivateの場合は、型を構成するデフォルトのアクセスレベルも同じ
    - 型全体のアクセスレベルがopen、public、internalの場合は型を構成する要素のデフォルトのアクセスレベルはinternal


// エクステンションのアクセスレベル
型の定義とそのエクステンションのスコープは本来別々だが、同一ファイル内のエクステンショに限り、同一スコープとみなされる。
これにより、もとの型のprivateな要素に同一ファイル内のエクステンションからもアクセスできる。


// モジュールヘッダ：モジュール外から参照可能なインタフェース
- C言語などとは異なり、Swiftでは、インタフェースを記述するヘッダファイルをプログラマが記述する必要はない。
- ヘッダファイルは存在しないが、その代わりにXcodeを通じて、外部からアクセス可能なインタフェースのみが記述されたモジュールのヘッダ情報を閲覧できる。
- モジュールヘッダを閲覧すると、モジュールの利用者はモジュールの実装を呼び飛ばして、インタフェースとドキュメントを読むことができる。


// モジュールヘッダの閲覧方法
モジュールヘッダを閲覧するには、「control + commandを押しながら、対象のモジュールをクリック」


// モジュールヘッダに記述される情報
モジュールヘッダには、モジュール外から利用可能なもののみが記述されるため、open、publicキーワードが指定されたもののみが出力される。


// ドキュメントコメント：コードの意図や使用方法の説明
Swiftのコメント
    - 通常のコメント：実装に対するコメントとして扱われ、モジュールヘッダにはエクスポートされない
    - ドキュメントコメント：インタフェースに対するコメントとして扱われ、モジュールの利用者が閲覧できるようにモジュールヘッダにも表示される


// Quick Help
- ドキュメントコメントはXcodeのQuick Helpに反映させる
- Xcodeのメニューから、View -> Inspectors -> Show Quick Help Inspector（option + command + 3）を選択することで確認できる
