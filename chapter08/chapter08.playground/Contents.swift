import Foundation

/*
 Swiftの型
    - 構造体
    - クラス
    - 列挙型
 
 型の共通の仕様
    - プロパティ
    - メソッド
 */

/*
 型の種類を使い分ける目的
    - プログラミングでは、データを「型」として表現する
 
 大抵のデータ構造は、「構造体」や「クラス」で表現できるようになっている
 しかし、構造体、クラス、列挙型はそれぞれの目的に特快した機能や仕様を持っている為、
 データの特定に応じて適切な種類を選択すれば、単なる値と機能の組み合わせ以上の表現が可能になる
 */

/*
 値の受け渡し方法による分類
 
 Swiftの3つの型の種類は、値の受け渡しによって大別
    - 値型
    - 参照型
 
 値型と参照型の最大の違いは、変更を他の変数や定数と共有するかどうか
    - 値型：変更を共有しない型
        - 構造体
        - 列挙型
    - 参照型：変更を共有する型
        - クラス
 */

/*
 値型：値を表す型
 値型：インスタンスが値への参照ではなく、値そのものを表す型
    - 構造体
    - 列挙型
 
 変数や定数への値型のインスタンスの代入：インスタンスが表す値そのものの代入を意味する
    - 複数の変数や定数で1つの値型のインスタンスを共有することはできない
    - 一度代入したインスタンスは再代入を行わない限り不変であり、その値が予測可能になるというメリットがある
 
 値型のインスタンスが値そのものを表すという仕様
    - 変数、定数への代入や関数への受け渡しのたびにコピーを行い、もとのインスタンスが表す値を不変にすることによって実現されている
 
 mutatingキーワード：自身の値の変更を宣言するキーワード
 値型：mutatingキーワードをメソッドの宣言時に追加することで、自身の値を変更する処理を実行できる
    - mutatingキーワードが指定されたメソッドを実行してインスタンスの値を変更すると、インスタンスが格納されている変数への暗黙的な再代入が行われる
    - mutating期キーワードが指定されたメソッドの呼び出しは再代入として扱われる為、定数に細田隠喩された値型のインスタンスに対しては実行できず、コンパイルエラーとなる
    - 定数に対して実行できないという仕様は、インスタンスが保持する値の変更を防ぎたい場合に役立つ
 
 [定義]
 mutating func メソッド名(引数) -> 戻り値の型 {
    // メソッド呼び出し時に実行される文
 }
 */

// 値型（Int型, Float型）
var a = 4.0
var b = a // bに4.0が入る（aが持つ4.0への参照ではなく値である4.0が入る）
a.formSquareRoot() // aの平方根を取る
print(a)
print(b)


struct Color {
    var red: Int
    var green: Int
    var blue: Int
}

var a2 = Color(red: 255, green: 0, blue: 0)
var b2 = a2
a2.red = 0 // aを黒に変更する

print(a2.red)
print(a2.green)
print(a2.blue)

// b2は赤のまま
print(b2.red)
print(b2.green)
print(b2.blue)


// mutatingキーワード
extension Int {
    mutating func increment() {
        self += 1
    }
}

var a3 = 1
a3.increment()
print(a3)


var mutableArray = [1, 2, 3]
mutableArray.append(4) // [1, 2, 3, 4]

let immutableArray = [1, 2, 3]
// bad: immutableArray.append(4)


/*
 参照型：値への参照を表す型
 参照型：インスタンスが値への参照を表す型
    - SwiftにおけるClass
    - 変数や定数への参照型の値の代入は、インスタンスに対する参照の代入を意味する為、複数の変数や定数で1つの参照型のインスタンスを共有できる
    - 変数や定数への代入時や関数への受け渡し時にはインスタンスのコピーが発生しないため、効率的なインスタンスの受け渡しができるというメリットがある
 
 値の変更の共有
 値型では、変数や定数は他の値の変更による影響を受けないことが保証されていた
 参照型では、1つのインスタンスが複数の変数や定数の間で共有される為、ある値に対する変更はインスタンスを共有している他の変数や定数にも伝播する
 */

class IntBox {
    var value: Int
    
    init(value: Int) {
        self.value = value
    }
}

var a4 = IntBox(value: 1) // aはIntBox(value: 1)を参照する
var b4 = a4 // bはaと同じインスタンスを参照する

print(a4.value)
print(b4.value)

// a4.valueを2に変更する
a4.value = 2
print(a4.value)
print(b4.value)


/*
 値型と参照型の使い分け
 値型は、変数や定数への代入や引数への受け渡しのたびにコピーされ、変更や共有されない。
 したがって、一度代入された値は、明示的に再代入しない限りは不変であることが保証される。
 一方の参照型はその逆であり、変数や定数への代入や引数への受け渡しの際にコピーされずに参照が渡されるため、変更が共有される。
 したがって、一度代入された値が変更されないことの保証は難しくなる。
 
 -> 安全にデータを取り扱うためには、積極的に値型を使用し、参照型は状態管理などの変更の共有が必要となる範囲にとどめるのが良い
 */

/*
 構造体：値型のデータ構造
 */
