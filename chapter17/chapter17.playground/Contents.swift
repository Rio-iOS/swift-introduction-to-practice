/*
 ユニットテスト：プログラムの構成要素を個別に検証する手法
    - プログラムの各部に対して様々な入力を与え、その出力が期待通りになることを確認する
 */

/*
 ユニットテストの目的
 
 プログラミング -> 小さなプログラムを組み合わせて、より大きなプログラムを構成する
 
 ユニットテスト：小さなプログラムレベルで動作の検証を行う手法
 
 ユニットテストによる検証は、テスト用のプログラムによって行われるため実行コストが低く、
 プログラムの更新ごとにすべてのテストを繰り返し実行することが一般的である。
 */

/*
 テストは、コアライブラリであるXCTestを使って記述する
 ユニットテストを用いることで、プログラムの特定の箇所を、様々な条件で検証できる。
 手入力でのテストに比べると、その実行コストは無視できる程度のもの
 そのため、変更の箇所にかかわらず、すべてのテストを実行することが一般的である。
 そうすることで、予期しない形でバグを混入してしまうことを防げる
 */

/*
 テストターゲットは、Package.swiftの.testTarget(name:dependencies:)の箇所で宣言される
 
 ユニットテストのソースコードは、ターゲット名と同名であるDemoTestsディレクトリ以下に配置する。
 テンプレートとして生成されるDemoTests.swiftのtestExample()メソッドには、Demoモジュールで定義されているDemo型に対するテストが記述されている
 */

/*
 テストは、XCTestCaseクラスを継承したクラス内に記述する
 「test」で始まる名前のメソッドが、それぞれテストとなる
 
 XCTestCaseクラスを利用するには、コアライブラリである「XCTest」をインポートする必要がある
 */

/*
 動作の検証は、XCTestが提供するアサーションを行う
 */

/*
 テスト対象のモジュールのインポート
 テスト対象のコードは、テストコードとは別のモジュールである。
 したがって、テストコードでは、常にテスト対象のモジュールをインポートする必要がある
 
 モジュール外からアクセスできるコードはアクセスレベルが「public」のものに限られる。
 しかし、これではテスト対象の要素をすべてをモジュール外に公開することになり、
 本来期待されているような形でアクセスレベルを利用できない。
 このような状況には対処するには、import文の「@testable」属性を利用する。
 import文に@testtable属性を追加すると、アクセスレベル「internal」の要素が「public」と同等の扱いになり、
 テストからアクセスできるようになる。
 */

/*
 アサーション：値の検証
 
 値の検証には、XCTestが提供するアサーションを利用する
    - (ex)
    - XCTAssertEqual(_:_:)
 
 XCTestは用途ごとにさまざまなアサーションを提供しており、4つに分類できる
    - 単一の式を評価するアサーション
    - 2つの式を比較するアサーション
    - エラーの有無を評価するアサーション
    - 無条件に失敗するアサーション
 
 
 式の値を評価するアサーション
 アサーション関数 | 式の型 | テストが成功する条件
 XCTAssert(_:)関数 | Bool型 | 引数の式がtrueを返す
 XCTAssertTrue(_:)関数 | Bool型 | 引数の式がtrueを返す
 XCTAssertFalse(_:)関数 | Bool型 | 引数の式がfalseを返す
 XCTAssertNil(_:)関数 | Optional<Wrapped> | 引数の式がnilを返す
 XCTAssertNotNil(_:)関数 | Optional<Wrapped> | 引数の式がnilでない値を返す
 
 XCTAssert(_:)関数とXCTAssertTrue(_:)関数の機能は同じ
 どちらを使っても問題ないが、読みやすさに影響しない限りは、より簡潔なXCTAssert(_:)関数を使う
 
 
 2つの式を評価するアサーション
 アサーション関数 | 式の型 | テストが成功する条件
 XCTAssertEqual(_:_:)関数 | Equatableプロトコルに準拠した型 | 2つの式の結果が等しい
 XCTAssertEqual(_:_:accuracy)関数 | FloatingPointプロトコルに準拠した型 | 2つの式の差分が第3引数でしていされた値よりも小さい
 XCTAssertNotEqual(_:_:)関数 | Equatableプロトコルに準拠した型 | 2つの式の結果が等しくない
 XCTAssertLessThan(_:_:)関数 | Comparableプロトコルに準拠した型 | 第1引数が第2引数より小さい
 XCTAssertLessThanOrEqual(_:_:)関数 | Comparableプロトコルに準拠した型 | 第1引数が第2引数以下
 XCTAssertGreaterThan(_:_:)関数 | Comparableプロトコルに準拠した型 | 第1引数が第2引数より大きい
 XCTAssertGreaterThanOrEqual(_:_:)関数 | Comparableプロトコルに準拠した型 | 第1引数が第2引数以上
 */

/*
 エラーの有無を評価するアサーション
 エラーの有無を評価するアサーションは、式がthrowキーワードによるエラーを発生させるかづかを評価する
 
 アサーション関数 | 式の型 | テストが成功する条件
 XCTAssertThrowsError(_:)関数 | 任意 | エラーが発生した
 XCTAssertNoThrow(_:)関数 | 任意 | エラーが発生しなかった
 */

/*
 無条件に失敗するアサーション
 XCTFail()関数は、無条件に失敗するアサーション関数
 無条件に失敗するアサーションは、テストが特定のパスを通らないことを保証したい場合などに使用する
 */


/*
 テストケース：テストをまとめる
 
 個々のテストはXCTestCaseクラスを継承したクラスのメソッドとして定義されている
 
 テストケース：同じクラス内に定義されたテストの集まり
    - 関連するテストは同じテストケース内に配置する
 
 テストはXCTestCaseクラスを継承したクラスのメソッドとして実行されるため、XCTestCaseクラスには
 テストの開始や終了のイベントを受け取ったり、テストの実行をコントロールする機能がある
 
 
 テストの事前処理と事後処理
 同じテストケース内の複数のテスト間には、共通の事前処理や事後処理が必要になることがある
    - (ex)
    - データベースを使用するテスト
        - 事前処理
            - テスト用のデータを作成する
        - 事後処理
            - 作成したデータを削除する
 
 事前処理：setUp()メソッド
 事後処理：tearDown()メソッド
 
 
 setUp()メソッド：テストの事前処理を行うメソッド
 setUp()メソッドはテストの事前処理を行うメソッド
    - テスト対象の状態のリセットや、一時ファイルの作成など、テストの前に必要な処理を実行
 
 setUp()メソッドには、インスタンスメソッドとクラスメソッドの両方がある
    - インスタンスメソッド：テストごとの事前処理
        - テストケースに対して一度だけ実行される
    - クラスメソッド：テストケース全体の事前処理
        - 個々のテストごとに実行される
 
 
 tearDown()メソッド：テストの事後処理を行うメソッド
 tearDown()メソッドは、テストの事後処理を行うメソッドである。
    - (ex)
    - 一時ファイルの削除
    - テストのあとに必要な処理
 
 tearDown()メソッドいは、インスタンスメソッドとクラスメソッドの両方がある
    - インスタンスメソッド：テストごとの事後処理
        - テストケースに対して一度だけ実行される
    - クラスメソッド：テストケース全体の事後処理
        - 個々のテストごとに実行される
 */

/*
 テストの実行のコントロール
 
 テストケースクラスに定義されたテストは、XCTestによって順次実行される
 XCTestCaseクラスにはテストの実行をコントロールする機能があり、
 テストを中断したり、非同期処理を待ち合わせたりすることができる。
 
 失敗時のテストの中断
 デフォルトでは、テストの途中でアサーションが失敗しても、後続の処理は実行される
 しかし、後続の処理が事前のアサーションの結果に依存している場合や、実行に時間のかかるテストなどでは、
 この挙動が問題になることがある。
 その場合、1つのアサーションの失敗をもってして、テスト全体を中断することができる
 
 実行時エラーが発生すると、ユニットテスト全体が停止してしまうため、以降のテストが実行されない
 これを避けるには、XCTestCaseクラスの「continueAfterFailureプロパティ」にfalseを指定する
 アサーションが失敗した時点でテストの実行が中断される
 */

/*
 エラーによるテストの中断
 テストメソッドにthrowsキーワードを付与すると、テストメソッドでエラーを発生させることができる。
 この場合、エラーが発生した時点で、そのテストは中断され、失敗したとみなされる
 */

/*
 非同期処理の待ち合わせ
 テストは同期的に行われるため、非同期処理が含まれる場合、その完了を待つ必要がある
 
 XCTestCaseクラスが提供する非同期処理の完了を待つ仕組みを利用する
 非同期処理を待ち合わせるには、「expectation(description:)メソッド」を呼び出す
 
 expectation(description:)：非同期処理の結果を表現するXCTestExpectationクラスの値を返却する。
 
 XCTestExpectationクラスの値を引数にして、wait(for:timeout:)メソッドを呼び出すことで、
 その場所でtimeoutで指定された時間、非同期処理の待ち合わせを行うことを宣言する
 timeoutで指定された時間内にXCTestExpectationクラスの値に対して、「fullfill()メソッド」が実行されない場合
 テストが失敗したとみなされる
 */


/*
 スタブ：テスト対象への入力を置き換える
 
 スタブ：テスト対象の依存先を置き換え、テスト用の入力を与えるためのテクニック
    - スタブは、主に外部システムとの連携部をテストする際に利用される
 
 (ex)
 サーバとの通信を行う箇所に対するテスト内で実際に通信を行うことは、以下の問題がある
    - ネットワークの状態にテスト結果が左右される
    - サーバの状態にテスト結果が左右される
    - 実行に時間がかかる
 
 ユニットテストはあくまでアプリケーション単体の動作を保証するためのテストである。
 テスト結果が外部システムに依存すると、問題の切り分けが困難となり、ユニットテスト本来の目的が損なわれる。
 
 こうした問題を解消するには、「スタブを利用して外部システムからの入力を置き換える」
    - (ex)
    - サーバとの通信では、実際には通信を行わず固定のレスポンスを返すタブを作成する
 
 テストダブル：スタブのようにテスト対象の依存先を置き換えるものの総称
    - (ex)
    - ダミー
    - フェイク
    - スパイ
    - モック
 
 これらは、テストのための仮の実装や、呼び出し結果の記録など、スタブとは異なる目的利用される
 */

/*
 プロトコルによる実装の差し替え
 スタブには、さまざまな実現方法があるが、プロトコルを用いる方法が一般的である
 まず、テスト対象に依存する型のプロパティやメソッドをプロトコルとして切り出す。
 テスト対象を、依存する型とプロトコルを通じてやりとりするように書き換える
 そうすることで、実際に依存する型を同じプロトコルに準拠した型と自由に置き換えることができる
 */
